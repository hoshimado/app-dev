# ソフトウェア設計

ソフトウェア開発において、設計はコアとなるものです。本章では、そういったプログラミングの本質的な作業である設計について記します。

ウォーターフォールのように上流工程・下流工程のように捉える考え方があります。その分類では設計とは上流工程であり、下流工程には設計の余地がないと思われることもありますが、実際にはプログラミングにおいては、要件定義から詳細設計、コーディングまで、ほとんどの工程に設計行為を含みます。

たとえば誰もがやっている分かりやすい設計行為はネーミングです。

ユーザーからヒアリングをして、ビジネスロジックを考えるときにも、概念や機能などに名前を付ける必要があります。

詳細設計をするときにはモジュールの名前を付ける必要があります。

コーディングをするときも、ファイル名、クラス、関数、変数、あらゆるものには名前を付ける必要があります。

## 名前の大切さ

あらゆる名前は、ソースコードの読みやすさや治安に直結します。ある関数の中身はその関数の名前に左右されます。

`readHoge` という名前の関数が読むという名前に反して、書き込みを行っていたとすれば、その関数は混乱しか生み出しません。この関数は名前を適切なものに変えるかべきですが、そもそもなぜそういった状況になってしまったのか？を洗い出す必要性があるかもしれません。

よくあるパターンとしては、本来は読む動作を期待して名前付けを行っていたが
、開発中の何かしらの事情で中身がどんどん変わっていき、最終的に名前と中身が乖離していたというものです。

問題の再発を心配しなくて済むなら、名前を変えればしまいですが、開発体制に何かしらの問題があり、再発しうるのであれば、名前を変えるというのはただの対症療法にしかならないでしょう。

### 名前の付け方

中で行うことの性質、何を行っているか **What** について、英単語でネーミングすることが推奨されます。英語化されている日本語はもちろんそのままでかまいません。`Tsunami`や`Karaoke`や`Karoushi`なんかは有名どころですね。他にも日本固有だと言い切れるもの、たとえば相撲の言葉なんかはローマ字を使うべきです。

なぜ英語にしなければいけないのか？既存のライブラリ、フレームワーク、OSのAPIその他はほぼ全てが英語です。中国で生まれたOSSも、ドイツで生まれたOSSも、フランスで生まれたOSSも英語です。

コンピュータ関連の情報は主に英語で記述されています。もちろん、日本には日本語の技術記事もありますし、海外の情報が翻訳されたものもあります。同様に韓国語で書かれた記事や中国語で書かれた記事もあります。

ただし、どの国に住んでいても英語を読まずに済ませられる機会はまず無いと思っていいと思います。

開発陣に日本人しかいないなら日本語でもいいかもしれません。ローマ字や、マルチバイト対応言語ならいっそ日本語を変数名や関数名にするという考え方もあるでしょう。一切新しい人材を採用しない現場ならローマ字でもカタカナでも漢字でも任意の文字列を付ければいいと思います。

ローマ字を使ったりした場合に問題になる一番の典型例は採用できる人材の幅を狭めてしまうことです。



関数やメソッドの名前は、動詞か、動詞+名詞が使われます。それ以外では名詞が使われます。






## ソースコードのWhat/Why/How

ソフトウェア開発の界隈で有名なt_wadaさん曰く

> コードには How
> テストコードには What
> コミットログには Why
> コードコメントには Why not
>
> を書こうという話をした

引用元: https://twitter.com/t_wada/status/904916106153828352

という有名なツイートがあります。

これでいうと名前は基本的にはWhatです。


### 責務・責任

ソフトウェア開発の世界にはよく責任や責務という言葉が登場します。
[^responsibility]: 責務は「義務を果たすべき責任」という意味です。

たとえば関数でいえば、ある入力に対してどのような出力を返すべきなのか？というのを責任を持って請け負うことを指します。5W1H的にはWhoという存在について考えることができます。関数には必ず、関数の呼び出し元がいます。関数は呼び出し元に対して責務を負っているといえます。

実際の処理内容はHowですが、呼び出し元からするとHowはどうでもいい情報です。むしろHowに踏み込んだ呼び出し方をすると、過度な密結合をしているということになります。

関数の名前は前述のとおりWhatであり、極力Howに踏み込んだネーミングはしてはいけませんが、その関数の仕様が詳細に踏み込んでいる場合、名前にその詳細が浸食してくることになります。

クラスやモジュールなどあらゆる単位で、責務という考え方は重要になります。

## プログラミングは全工程が設計そのものである。どこまでいっても設計


## アプリ開発は、コストその他のバーター

<!--
  これは別の章に分けた方がいいかも？
-->

## 技術的負債

技術的負債とは、技術的な複雑さ、改修しづらさを、経済的な負債に見立てる有名な比喩表現です。

人によりますが、読みやすくメンテナンスしやすいコードを書こうとすると時間がかかるということがあります。環境構築をサボって取り急ぎ作業をすることもあるでしょう。そういった行為によって、初期の開発速度は上がるものの、後のメンテナンスコストが増大するという現象は色々な現場で見受けられるものです。

負債は必ずしも返済する義務があるわけではありません。負債を踏み倒すというのは、現実的に行われうる選択肢の1つです。

### 循環的複雑度

循環的複雑度は、関数やメソッドのもつ複雑さを数値化したものです。計算方法はif/forなどの制御構造による分岐数を数えるだけです。言い換えると循環的複雑度はその関数やメソッドを実行した時の通り道の組み合わせの数です。

<!--
FIXME: 計算式を書く
-->

循環的複雑度が大きくなればなるほど、バグの生じる可能性は増えるとされています。ユニットテストのテストケース数も増大します。

<!--
FIXME: 数値ごとのバグ発生率の表を書く
-->

1つの関数やメソッドは、循環的複雑度を一定の数に収めるべきです。

### モジュール安定度

<!--
FIXME: 移動する
-->
ここでいう安定度は必ずしも、バグが無い、変更が加わらないという意味ではありません。そのモジュールへ依存するモジュールが多ければ多いほどそのモジュールは安定しているといいます。

因果関係の逆転現象とでもいうべきでしょう。依存されていると、自身を変更したときに影響範囲は依存元に及びます。その数が多ければ多いモジュールは、変更したときの影響範囲が大きいモジュールであり、そういったモジュールは必然的にバグが無く、なるべく変更が無い、特に仕様の互換性が必要になるという意味を持ちます。

依存するなら、そういった安定度の高いモジュールに依存すべきです。

### 結合度（疎結合と密結合）

### 凝集度（高凝集性と低凝集性）

### 読みやすさ・読みづらさ

ここまで取り上げてきた事柄は技術的負債の中でも、数値的指標を求めやすいものでしたが、読みやすさ・読みづらさは数値化しづらいものですがある程度の考え方の原則のようなものはあります。

人間が考えるときにつかう脳内モデルに反するようなもの、直感的ではないものは読みづらい傾向にあります。人によっては、美しさで例える人がいますが、驚き最小の原則という言い方もあります。

> ユーザインタフェースやプログラミング言語の設計および人間工学において、インタフェースの2つの要素が互いに矛盾あるいは不明瞭だったときに、その動作としては人間のユーザやプログラマが最も自然に思える（驚きが少ない）ものを選択すべきだとする考え方である。[^principle-of-least-suprise]

[^principle-of-least-suprise]: 日本語のこの文章は https://ja.wikipedia.org/wiki/%E9%A9%9A%E3%81%8D%E6%9C%80%E5%B0%8F%E3%81%AE%E5%8E%9F%E5%89%87 から引用しました。







読みやすさについては、細かく自転車置き場議論[^bikeshed-color]になりやすい

[^bikeshed-color]: 自転車置き場の屋根を何色に塗るかを延々議論することを、自転車置き場議論などと呼びます。人によって好みの分かれるような、ある意味どうでもいいことを指します。ソースコードの読みやすさに関しても、好みの問題は多く含まれているため、注意しなければいけません。

## 人類の知恵

技術的負債に対抗するため、人類は50年以上設計論を改善し続けてきました。

### プログラミングパラダイム

最初期のコンピュータプログラミングは、物理配線の付け替えで行われていました。原型となった階差機関や解析機関とよばれるものは歯車やギアを蒸気で駆動するものでした。

そういったものがLSIとなり、CPUがこの世に登場し、CPUが解釈できる数字列がマシン語と呼ばれるものになりました。マシン語はさらにアセンブリ言語という、少しだけ人間に優しいものから生成できるようになったり、アセンブリ言語やマシン語に変換できる高級言語というものが生み出されました。

<!--

* 構造化プログラミング
* オブジェクト指向
* 関数型言語
* 静的型 vs 動的型

-->

### SOLID原則




### デザインパターン

* GoF
* PoEAA
* DSL

#### [column] パターンを暗記するな

#### [/column]

### 図を興す（UML・ER図など）

## 境界線を引く

ここまでで説明したように、技術的負債を防ぐためには



### モジュール
### コンポーネント
### サービス
### レイヤードアーキテクチャ
### モノリシック vs マイクロサービス

## 設計論は大体プログラミング言語に左右されてしまう話

### 手続き型
### OOP
### 関数型

## 型
### ダックタイピング
### 動的型付け言語にも型はある
### 型の魔術
### 型は安心感

## 抽象と具象

### 具象（詳細）の悪夢、昨日の常識は明日の非常識になる
### 詳細決定は、出来うる限り後に回せ
### 抽象化は、必ずしも共通項の括りだしとは限らない

#### [column] 式年遷宮

## スケールアウトとスケールアップ
