# ソフトウェア設計

ソフトウェア開発において、設計はコアとなるものです。本章では、そういったプログラミングの本質的な作業である設計について記します。

ウォーターフォールのように上流工程・下流工程のように捉える考え方があります。その分類では設計とは上流工程であり、下流工程には設計の余地がないと思われることもありますが、実際にはプログラミングにおいては、要件定義から詳細設計、コーディングまで、ほとんどの工程に設計行為を含みます。

たとえば誰もがやっている分かりやすい設計行為はネーミングです。

ユーザーからヒアリングをして、ビジネスロジックを考えるときにも、概念や機能などに名前を付ける必要があります。

詳細設計をするときにはモジュールの名前を付ける必要があります。

コーディングをするときも、ファイル名、クラス、関数、変数、あらゆるものには名前を付ける必要があります。

## 名前の大切さ

あらゆる名前は、ソースコードの読みやすさや治安[^dangerous-code]に直結します。ある関数の中身はその関数の名前に左右されます。

[^dangerous-code]: 皆さんも見に覚えがありませんか？すでに前例があるからと言って、読みづらいけどさくっと書けるコードを追加していく行為。読みやすいコードを書く気がなくなるプロジェクト。あたかもスラム街の如く治安の悪いプロダクトを…。ここでいう治安は、ソースコードに秩序がなくなり、力がすべてを支配する世界となってしまった状態を指します。

名前の付け方は、中で行うことの性質、何を行っているか **What** について、英単語でネーミングすることが推奨されます。

関数やメソッドの名前は、動詞か、動詞+名詞が使われます。それ以外では名詞が使われます。

### 英語がすべての基本

なぜ英語にしなければいけないのか？既存のライブラリ、フレームワーク、OSのAPIその他はほぼ全てが英語です。中国で生まれたOSSも、ドイツで生まれたOSSも、フランスで生まれたOSSも英語です。

コンピュータ関連の情報は主に英語で記述されています。残念ながら日本初の技術はもう殆どなく、大半はアメリカや中国から生まれています。また日本で生まれて世界で通用する技術は例外なく英語が重要視されています。

もちろん、日本には日本語の技術記事もありますし、海外の情報が翻訳されたものもあります。同様に韓国語で書かれた記事や中国語で書かれた記事もあります。

しかし、どの国に住んでいても英語を読まずに済ませられる機会はまずありません。

開発陣に日本人しかいないなら日本語でもいいかもしれません。ローマ字や、マルチバイト対応言語ならいっそ日本語を変数名や関数名にするという考え方もあるでしょう。一切新しい人材を採用しない現場ならローマ字でもカタカナでも漢字でも任意の文字列を付ければいいと思います。

ローマ字を使ったりした場合に問題になる一番の典型例は、採用できる人材が狭まることです。日本人以外を取ることができなくなるか、できたとしても現場に混乱をもたらすでしょう。日本人だとしても、英語のドキュメントに慣れた人材はローマ字で書かれた変数名を嫌がります。

ただし、英語化されている日本語はもちろんそのままでかまいません。`Tsunami`や`Karaoke`や`Karoushi`なんかは有名どころですね。他にも日本固有だと言い切れるもの、たとえば相撲の言葉なんかは日本語を使うべきです。

### 名実を一致させる

たとえば `readHoge` という名前の関数が読む `read` という名前に反して、書き込み `write` を行っていたとすれば、その関数は混乱しか生み出しません。この関数は名前を適切なものに変えるかべきですが、そもそもなぜそういった状況になってしまったのか？を洗い出す必要性があるかもしれません。

よくあるパターンとしては、本来は読む動作を期待して名前付けを行っていたが、開発中の何かしらの事情で中身がどんどん変わっていき、最終的に名前と中身が乖離していたというものです。

名前と中身、つまり名実が一致してないと何が起こるのでしょうか？

* 認知不協和を発生させ、ソースコードを管理するコストが増大する
* 名前に事実上の意味がなくなり、誰も名前に関心を払わなくなる

そう、プロジェクトの治安の悪化です。場合によっては学習的無気力感により、メンバーのメンタルが壊され、人員が不足するかもしれません。

最悪の未来を回避するためにも名前と実態を一致させる必要があります。

* 名前を実態に合わせる
* 実態を名前に合わせる

名前を優先するか実態を優先するか？

ただし、前述のような `read` と名前のついた関数なのに、実は `write` を含んでいるような事例では、実態を変えるべきでしょう。これはいわゆるリファクタリングというもので、リファクタリングとは処理の内容・機能を変更せずに、コードの綺麗さを整えることです。

`readHoge` の中の処理がどれくらい絡み合っているか次第ですが、もし単純に分割可能であれば分割すべきです。`readHoge` と `writeFuga` の2種類に分割すれば、名前と実態が一致するならそれが楽でしょう。

実際にはリファクタリングをするためにはもう少し面倒なことが待っているかもしれませんが、ここではいったんリファクタリングについて詳細には触れません。

#### [column] 問題のある匂い

問題の再発を心配しなくて済むなら、名前を変えればしまいですが、開発体制に何かしらの問題があり、再発しうるのであれば、名前を変えるというのはただの対症療法にしかならないでしょう。

名前はある種の匂いです。

現実世界では、生物は危険な匂いのするものをまず食べません。腐った匂いのものを食べると、著しく健康を害するためです。匂いはセンサーだといえます。

ソースコードでも同様です。実態と一致しない名前を持った関数や変数、そういったものを見かけたら、それは危険サインです。

プログラマが経験を積むと、こういった匂いに敏感になります。

匂いがあるコードは、必ずしも改善する必要があるとはかぎりませんが、リファクタリングをするときには、匂いは重要なヒントになります。

#### [/column]

## ソースコードのWhat/Why/How

ソフトウェア開発の界隈で有名なt_wadaさん曰く

> コードには How
> テストコードには What
> コミットログには Why
> コードコメントには Why not
>
> を書こうという話をした

引用元: https://twitter.com/t_wada/status/904916106153828352

という有名なツイートがあります。

これでいうと名前は基本的にはWhatです。

### 名前に紛れ込むHow

ある関数の中身であるコードはHowですが、その関数の呼び出し元からするとHowはどうでもいい情報です。むしろHowに踏み込むと結合度が上がります。Howを共有するのが密結合なのです。

関数の名前は前述のとおりWhatであり、極力Howに踏み込んだネーミングはしてはいけませんが、その関数の仕様が詳細に踏み込んでいる場合、名前にその詳細が浸食してくることになります。

たとえば `readPriceFromDB` は値段情報をDB（データベース）から読み込むという名前です。本来 `FromDB` というのはHowです。値段情報がDBだろうが他の何に保存されていようが、本来は構わないはずですが、データベースから値段を読み出す関数が `readPrice` だったとすれば、それは名実が一致していない状態です。

ただしHowを共有するのは密結合への道です。ビジネスロジックはHowには一切触れるべきではありません。ビジネスロジックというのは、あなたが作ろうとしているアプリのコアです。たとえばホテルの予約アプリであれば、予約に関するロジックがビジネスロジックです。予約に関するロジックが、Howに踏み込む必要性はありませんよね？

ビジネスロジックはHowに触れると密結合と暗い未来しか待ち構えていないため、ビジネスロジックからアクセスするものをすべて `readPrice` のような、Howから切り離したものに限定すればいいでしょう。

このとき、`readPrice`はただのインターフェースで実態を持っていないかもしれません。`readPriceFromDB`の引数が、`readPrice`で提供されるべき引数と同じであれば、`readPrice`というインターフェースで、その実装が`readPriceFromDB`であるというふうにできます。

もし追加の引数が必要であれば、何かしらのサービスやファクトリ、依存性注入などの考え方を駆使することになるでしょう。これは後ほどまた詳しく説明します。

* DBから値段を読み込む関数に`readPrice`という名前を付けると嘘になる
* ビジネスロジックにとっては`readPriceFromDB`というHowに踏み込んだものを呼び出すべきではない
* `readPriceFromDB`とビジネスロジックをつなぎこむための`readPrice`が必要になる

この流れを忘れないようにしましょう。ソースコード、プロジェクトの治安を守るための第一歩です。

## 技術的負債

技術的負債とは、技術的な複雑さ、改修しづらさを、経済的な負債に見立てる有名な比喩表現です。本章で度々でてきた **治安** という言葉も技術的負債と同じような意味合いです。

読みやすくメンテナンスしやすいコードを書こうとすると時間がかかるということがあります。環境構築をサボって取り急ぎ作業をすることもあるでしょう。そういった行為によって、初期の開発速度は上がるものの、後のメンテナンスコストが増大するという現象は色々な現場で見受けられるものです。

負債は必ずしも返済する義務があるわけではありません。負債を踏み倒すというのは、現実的に行われうる選択肢の1つです。

### 循環的複雑度

循環的複雑度は、関数やメソッドのもつ複雑さを数値化したものです。計算方法はif/forなどの制御構造による分岐数を数えるだけです。言い換えると循環的複雑度はその関数やメソッドを実行した時の通り道の組み合わせの数です。

<!--
FIXME: 計算式を書く
-->

循環的複雑度が大きくなればなるほど、バグの生じる可能性は増えるとされています。ユニットテストのテストケース数も増大します。

<!--
FIXME: 数値ごとのバグ発生率の表を書く
-->

1つの関数やメソッドは、循環的複雑度を一定の数に収めるべきです。

### モジュール安定度

<!--
FIXME: 移動する
-->
ここでいう安定度は必ずしも、バグが無い、変更が加わらないという意味ではありません。そのモジュールへ依存するモジュールが多ければ多いほどそのモジュールは安定しているといいます。

因果関係の逆転現象とでもいうべきでしょう。依存されていると、自身を変更したときに影響範囲は依存元に及びます。その数が多ければ多いモジュールは、変更したときの影響範囲が大きいモジュールであり、そういったモジュールは必然的にバグが無く、なるべく変更が無い、特に仕様の互換性が必要になるという意味を持ちます。

依存するなら、そういった安定度の高いモジュールに依存すべきです。

### 結合度（疎結合と密結合）





### 凝集度（高凝集性と低凝集性）

### 読みやすさ・読みづらさ

ここまで取り上げてきた事柄は技術的負債の中でも、数値的指標を求めやすいものでしたが、読みやすさ・読みづらさは数値化しづらいものです。しかしある程度考え方の原則のようなものはあります。

人間が考えるときにつかう脳内モデルに反するようなもの、直感的ではないものは読みづらい傾向にあります。人によっては、美しさで例える人がいますが、驚き最小の原則という言い方もあります。

> ユーザインタフェースやプログラミング言語の設計および人間工学において、インタフェースの2つの要素が互いに矛盾あるいは不明瞭だったときに、その動作としては人間のユーザやプログラマが最も自然に思える（驚きが少ない）ものを選択すべきだとする考え方である。[^principle-of-least-suprise]

[^principle-of-least-suprise]: 日本語のこの文章は https://ja.wikipedia.org/wiki/%E9%A9%9A%E3%81%8D%E6%9C%80%E5%B0%8F%E3%81%AE%E5%8E%9F%E5%89%87 から引用しました。

前述の名前付けについて、名実が一致していないのは論外ですが、紛らわしいネーミングをする、その言語ではあまり見かけないコードの書き方をする、同じプロジェクトの中で同じことを別の書き方で書くなどは、読みづらさに直結するものでしょう。

認知的不協和という指摘もできるでしょう。何かしらの矛盾を抱えた存在は心にストレスを与えます。

メンタルモデルという考え方もあります。脳内で理解している事柄と現実のズレは、読みづらさになります。

ただし、読みやすさ・読みづらさは人によって異なる部分もあり、自転車置き場議論[^bikeshed-color]になりがちなことに注意しましょう。

[^bikeshed-color]: 自転車置き場の屋根を何色に塗るかを延々議論することを、自転車置き場議論などと呼びます。人によって好みの分かれるような、ある意味どうでもいいことを指します。ソースコードの読みやすさに関しても、好みの問題は多く含まれているため、注意しなければいけません。




## 人類の知恵

技術的負債に対抗するため、人類は50年以上設計論を改善し続けてきました。

### プログラミングパラダイム

最初期のコンピュータプログラミングは、物理配線の付け替えで行われていました。原型となった階差機関や解析機関とよばれるものは歯車やギアを蒸気で駆動するものでした。

そういったものがLSIとなり、CPUがこの世に登場し、CPUが解釈できる数字列がマシン語と呼ばれるものになりました。マシン語はさらにアセンブリ言語という、少しだけ人間に優しいものから生成できるようになったり、アセンブリ言語やマシン語に変換できる高級言語というものが生み出されました。

<!--

* 構造化プログラミング
* オブジェクト指向
* 関数型言語
* 静的型 vs 動的型

-->

### SOLID原則




### デザインパターン

* GoF
* PoEAA
* DSL

#### [column] パターンを暗記するな

#### [/column]

### 図を興す（UML・ER図など）

## 境界線を引く

ここまでで説明したように、技術的負債を防ぐためには



### モジュール
### コンポーネント
### サービス
### レイヤードアーキテクチャ
### モノリシック vs マイクロサービス

## 設計論は大体プログラミング言語に左右されてしまう話

### 手続き型
### OOP
### 関数型

## 型
### ダックタイピング
### 動的型付け言語にも型はある
### 型の魔術
### 型は安心感

## 抽象と具象

### 具象（詳細）の悪夢、昨日の常識は明日の非常識になる
### 詳細決定は、出来うる限り後に回せ
### 抽象化は、必ずしも共通項の括りだしとは限らない

#### [column] 式年遷宮

## スケールアウトとスケールアップ
